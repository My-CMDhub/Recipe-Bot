-- =====================================================
-- GROCERY PREDICTION SYSTEM - DATABASE SCHEMA
-- =====================================================
-- This creates all tables needed for receipt processing,
-- grocery predictions, feedback, and learning system
-- =====================================================

-- =====================================================
-- TABLE 1: receipts
-- =====================================================
-- Purpose: Store receipt metadata and OCR extraction status
-- Think of it as: A filing cabinet for all your receipts
-- =====================================================
CREATE TABLE IF NOT EXISTS receipts (
    id BIGSERIAL PRIMARY KEY,
    
    -- Who sent this receipt (WhatsApp phone number)
    user_phone TEXT NOT NULL,
    
    -- Where the image is stored (WhatsApp media URL or file path)
    image_url TEXT,
    
    -- Store name extracted from receipt (or "Unknown Store")
    store_name TEXT,
    
    -- When was this purchase made?
    purchase_date DATE NOT NULL,
    
    -- Is the date estimated? (True if we couldn't extract it from receipt)
    date_is_estimated BOOLEAN DEFAULT FALSE,
    
    -- Raw response from Unstract API (for debugging)
    unstract_response JSONB,
    
    -- Status of extraction: 'pending', 'processing', 'success', 'failed'
    extraction_status TEXT DEFAULT 'pending',
    
    -- If extraction failed, what was the error?
    error_message TEXT,
    
    -- When was this receipt uploaded?
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- When was it last updated?
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for faster lookups by user and date
CREATE INDEX IF NOT EXISTS idx_receipts_user_phone ON receipts(user_phone);
CREATE INDEX IF NOT EXISTS idx_receipts_purchase_date ON receipts(purchase_date);
CREATE INDEX IF NOT EXISTS idx_receipts_extraction_status ON receipts(extraction_status);

-- =====================================================
-- TABLE 2: receipt_items
-- =====================================================
-- Purpose: Store individual items from each receipt
-- Think of it as: The detailed shopping list from each receipt
-- Relationship: Many items belong to one receipt (one-to-many)
-- =====================================================
CREATE TABLE IF NOT EXISTS receipt_items (
    id BIGSERIAL PRIMARY KEY,
    
    -- Which receipt does this item belong to?
    receipt_id BIGINT NOT NULL REFERENCES receipts(id) ON DELETE CASCADE,
    
    -- Original item name from OCR (before cleaning)
    item_name_raw TEXT NOT NULL,
    
    -- Cleaned and normalized item name (after AI processing)
    item_name_normalized TEXT NOT NULL,
    
    -- How many? (e.g., 2.0 for "2 bottles")
    quantity DECIMAL(10, 2),
    
    -- Price per unit (e.g., 4.50 for one bottle)
    unit_price DECIMAL(10, 2),
    
    -- Total price for this item (quantity * unit_price)
    total_price DECIMAL(10, 2),
    
    -- How was this normalized? 'ai_normalized', 'custom_normalized', 'failed'
    normalization_status TEXT DEFAULT 'pending',
    
    -- Which AI model normalized it? 'mistral', 'gemini', 'custom'
    normalization_model TEXT,
    
    -- When was this item added?
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_receipt_items_receipt_id ON receipt_items(receipt_id);
CREATE INDEX IF NOT EXISTS idx_receipt_items_normalized_name ON receipt_items(item_name_normalized);

-- =====================================================
-- TABLE 3: predictions
-- =====================================================
-- Purpose: Store grocery predictions generated by AI
-- Think of it as: The AI's "shopping suggestions" for you
-- =====================================================
CREATE TABLE IF NOT EXISTS predictions (
    id BIGSERIAL PRIMARY KEY,
    
    -- Who is this prediction for?
    user_phone TEXT NOT NULL,
    
    -- When was this prediction generated?
    prediction_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- When should you shop? (start of range)
    predicted_date_range_start DATE,
    
    -- When should you shop? (end of range)
    predicted_date_range_end DATE,
    
    -- What items are predicted? (JSON array: ["milk", "bread", "eggs"])
    predicted_items JSONB NOT NULL,
    
    -- How confident is the AI? (0.0 to 1.0, e.g., 0.85 = 85%)
    confidence_score DECIMAL(3, 2),
    
    -- Why did AI predict these items? (short explanation)
    reasoning TEXT,
    
    -- Which LLM generated this? 'gemini', 'mistral', 'deepseek', 'openai'
    llm_used TEXT,
    
    -- The prompt sent to LLM (for debugging)
    llm_prompt TEXT,
    
    -- Full LLM response (for debugging and analysis)
    llm_response JSONB,
    
    -- Current status: 'pending_feedback', 'completed', 'expired', 'cancelled'
    status TEXT DEFAULT 'pending_feedback',
    
    -- When was this prediction created?
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- When does the feedback session expire? (5 hours or end of day)
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL
);

-- Indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_predictions_user_phone ON predictions(user_phone);
CREATE INDEX IF NOT EXISTS idx_predictions_status ON predictions(status);
CREATE INDEX IF NOT EXISTS idx_predictions_expires_at ON predictions(expires_at);

-- =====================================================
-- TABLE 4: prediction_feedback
-- =====================================================
-- Purpose: Store feedback when user shops and submits receipt
-- Think of it as: "Did the AI get it right?" tracking
-- Relationship: One prediction can have one feedback
-- =====================================================
CREATE TABLE IF NOT EXISTS prediction_feedback (
    id BIGSERIAL PRIMARY KEY,
    
    -- Which prediction is this feedback for?
    prediction_id BIGINT NOT NULL REFERENCES predictions(id) ON DELETE CASCADE,
    
    -- The receipt user submitted after shopping (if any)
    feedback_receipt_id BIGINT REFERENCES receipts(id),
    
    -- What items did user actually buy? (JSON array)
    actual_items_purchased JSONB NOT NULL,
    
    -- How accurate was the prediction? (0-100, e.g., 85.5)
    match_percentage DECIMAL(5, 2),
    
    -- Which items matched? (JSON array)
    matched_items JSONB,
    
    -- Which items were predicted but NOT bought? (JSON array)
    missing_items JSONB,
    
    -- Which items were bought but NOT predicted? (JSON array)
    extra_items JSONB,
    
    -- Any manual corrections user provided?
    user_corrections TEXT,
    
    -- Feedback status: 'submitted', 'no_response', 'cancelled'
    feedback_status TEXT DEFAULT 'submitted',
    
    -- When was feedback submitted?
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS idx_feedback_prediction_id ON prediction_feedback(prediction_id);

-- =====================================================
-- TABLE 5: feedback_sessions
-- =====================================================
-- Purpose: Track active feedback sessions (5-hour wait period)
-- Think of it as: A timer tracking if user will submit receipt
-- Relationship: One prediction = one feedback session
-- =====================================================
CREATE TABLE IF NOT EXISTS feedback_sessions (
    id BIGSERIAL PRIMARY KEY,
    
    -- Which prediction is this session for?
    prediction_id BIGINT NOT NULL REFERENCES predictions(id) ON DELETE CASCADE,
    
    -- Who is waiting for feedback?
    user_phone TEXT NOT NULL,
    
    -- Current session status
    -- 'waiting' = waiting for receipt
    -- 'receipt_submitted' = user submitted receipt
    -- 'no_response' = user said "No"
    -- 'expired' = 5 hours passed or midnight
    -- 'cancelled' = user cancelled
    session_status TEXT DEFAULT 'waiting',
    
    -- When was session created?
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- When does session expire? (5 hours after prediction or midnight)
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    
    -- When was reminder sent? (after 5 hours)
    reminder_sent_at TIMESTAMP WITH TIME ZONE,
    
    -- When was session last updated?
    last_updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for faster session lookups
CREATE INDEX IF NOT EXISTS idx_sessions_prediction_id ON feedback_sessions(prediction_id);
CREATE INDEX IF NOT EXISTS idx_sessions_status ON feedback_sessions(session_status);
CREATE INDEX IF NOT EXISTS idx_sessions_expires_at ON feedback_sessions(expires_at);

-- =====================================================
-- TABLE 6: learning_updates
-- =====================================================
-- Purpose: Track when AI learns from feedback (batch learning)
-- Think of it as: A log of "AI improvement sessions"
-- =====================================================
CREATE TABLE IF NOT EXISTS learning_updates (
    id BIGSERIAL PRIMARY KEY,
    
    -- What type of learning? 'batch_learning', 'pattern_update'
    update_type TEXT NOT NULL,
    
    -- How many feedbacks were used for this learning?
    feedback_count INTEGER NOT NULL,
    
    -- What was learned? (JSON summary)
    update_summary JSONB,
    
    -- How much did accuracy improve? (before/after comparison)
    accuracy_improvement DECIMAL(5, 2),
    
    -- When did this learning happen?
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for tracking learning over time
CREATE INDEX IF NOT EXISTS idx_learning_created_at ON learning_updates(created_at);

-- =====================================================
-- AUTOMATIC UPDATED_AT TRIGGER
-- =====================================================
-- This automatically updates the 'updated_at' field 
-- whenever a receipt is modified
-- =====================================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_receipts_updated_at
    BEFORE UPDATE ON receipts
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sessions_updated_at
    BEFORE UPDATE ON feedback_sessions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- DATA EXPIRATION (1 year cleanup)
-- =====================================================
-- Optional: You can add a scheduled job to delete old receipts
-- after 1 year. For now, we'll handle this in application code.
-- =====================================================